<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

    <script src="../brain.js/browser.min.js"></script>

    <style>
    
    body {
        background-color: #333333;
    }

    #canvas {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        bottom: 0;
        margin: auto;
        background-color: #fff;
    }
    
    </style>
</head>
<body>
    
    <canvas id="canvas" style="display: block">Ваш браузер устарел, обновитесь.</canvas>


    <script>
    
    let canvas = document.getElementById('canvas');
    
    function DCanvas(canv) {
        const ctx = canv.getContext('2d');
        const pixel = 20;

        let isMouseDown = false;

        canvas.width = 500;
        canvas.height = 500;

        // рисуем линию
        this.drawLine = function(x1, y1, x2, y2, color = 'gray') {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineJoin = 'miter';
            ctx.lineWidth = 1;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        // отобразить нарисованное в ячейках
        this.drawCell = function(x, y, w, h) {
            ctx.fillStyle = 'blue';
            ctx.strokeStyle = 'blue';
            ctx.lineJoin = 'miter';
            ctx.lineWidth = 1;
            ctx.rect(x, y, w, h);
            ctx.fill();
        }

        // очистить поле
        this.clear = function() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // создаем сетку
        this.drawGrid = function() {
            const w = canvas.width;
            const h = canvas.height;
            const p = w / pixel;

            const xStep = w / p;
            const yStep = h / p;

            for( let x = 0; x < w; x += xStep ) {
                this.drawLine(x, 0, x, h);
            }

            for( let y = 0; y < h; y += yStep ) {
                this.drawLine(0, y, w, y);
            }
        }

        // заполняем поле нулей/единиц
        this.calculate = function(draw = false) {
            const w = canvas.width;
            const h = canvas.height;
            const p = w / pixel;

            const xStep = w / p;
            const yStep = h / p;

            const vector = []
            let __draw = [];

            for( let x = 0; x < w; x += xStep ) {
                for( let y = 0; y < h; y += yStep ) {
                    const data = ctx.getImageData(x, y, xStep, yStep);

                    let nonEmptyPixelsCount = 0;
                    for( let i = 0; i < data.data.length; i += 10 ) {
                        const isEmpty = data.data[i] === 0;

                        if(!isEmpty) nonEmptyPixelsCount += 1;
                    }

                    if( nonEmptyPixelsCount > 1 && draw ) {
                        __draw.push([x, y, xStep, yStep]);
                    }

                    vector.push(nonEmptyPixelsCount > 1 ? 1 : 0);
                }
            }

            if(draw) {
                this.clear();
                this.drawGrid();

                for( _d in __draw ) {
                    this.drawCell( __draw[_d][0], __draw[_d][1],
                     __draw[_d][2], __draw[_d][3] );
                }
            }

            return vector;
        }

        // рисование
        canv.addEventListener('mousedown', function(e) {
            isMouseDown = true;
            ctx.beginPath();
        });

        canv.addEventListener('mouseup', function(e) {
             isMouseDown = false
        });

        canv.addEventListener('mousemove', function(e) {
            if(isMouseDown) {
                ctx.fillStyle = 'red';
                ctx.strokeStyle = 'red';
                ctx.lineWidth = pixel;

                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(e.offsetX, e.offsetY, pixel / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(e.offsetX, e.offsetY);
            }
        })
    }    

    let vector = [];
    let net = null;
    let train_data = [];

    const d = new DCanvas(document.getElementById('canvas'));

    document.addEventListener('keypress', function(e) {

        if(e.key.toLowerCase() == 'c') d.clear();

        if(e.key.toLowerCase() == 'v') {
            vector = d.calculate(true);

            // train
            if( confirm('Possitive?') ) {
                train_data.push({
                    input: vector,
                    output: {likbes: 1}
                });
            } else {
                train_data.push({
                    input: vector,
                    output: {kirrill: 1}
                });
            }
        }

        if(e.key.toLowerCase() == 'b') {
            net = new brain.NeuralNetwork();
            net.train(train_data, {log: true});

            const result = brain.likely(d.calculate(), net);
            alert(result);
        }
    })
    </script>
</body>
</html>